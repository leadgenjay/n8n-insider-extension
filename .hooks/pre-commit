#!/bin/bash

# Secret Detection Pre-Commit Hook
# Prevents committing files containing API keys, tokens, and other secrets

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Scanning for exposed secrets...${NC}"

# Get list of staged files (excluding deleted files)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

# Define secret patterns to detect
declare -a PATTERNS=(
    # HighLevel / GoHighLevel tokens
    "pit-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"

    # Supabase tokens
    "sbp_[a-f0-9]{40}"
    "service_role.*eyJ[A-Za-z0-9_-]{20,}"

    # Generic JWT tokens (Supabase, etc)
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\.[A-Za-z0-9_-]{50,}\.[A-Za-z0-9_-]{20,}"

    # AWS keys
    "AKIA[0-9A-Z]{16}"
    "aws_secret_access_key.*[A-Za-z0-9/+=]{40}"

    # OpenAI / OpenRouter API keys
    "sk-[a-zA-Z0-9]{32,}"
    "sk-or-[a-zA-Z0-9-]{50,}"

    # Stripe keys
    "sk_live_[a-zA-Z0-9]{24,}"
    "sk_test_[a-zA-Z0-9]{24,}"
    "rk_live_[a-zA-Z0-9]{24,}"

    # GitHub tokens
    "ghp_[a-zA-Z0-9]{36}"
    "gho_[a-zA-Z0-9]{36}"
    "ghu_[a-zA-Z0-9]{36}"
    "ghs_[a-zA-Z0-9]{36}"
    "ghr_[a-zA-Z0-9]{36}"

    # Slack tokens
    "xox[baprs]-[0-9]{10,}-[a-zA-Z0-9-]+"

    # Google API keys
    "AIza[0-9A-Za-z_-]{35}"

    # Private keys
    "-----BEGIN.*PRIVATE KEY-----"

    # Generic patterns
    "password\s*[:=]\s*['\"][^'\"]{8,}['\"]"
    "api[_-]?key\s*[:=]\s*['\"][a-zA-Z0-9_-]{20,}['\"]"
    "secret\s*[:=]\s*['\"][a-zA-Z0-9_-]{20,}['\"]"
)

# Files/patterns to exclude from scanning
EXCLUDE_PATTERNS="\.lock$|package-lock\.json$|pnpm-lock\.yaml$|yarn\.lock$|\.min\.js$|\.map$"

FOUND_SECRETS=0
SECRETS_REPORT=""

for FILE in $STAGED_FILES; do
    # Skip excluded files
    if echo "$FILE" | grep -qE "$EXCLUDE_PATTERNS"; then
        continue
    fi

    # Skip binary files
    if file "$FILE" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    # Check if file exists
    if [ ! -f "$FILE" ]; then
        continue
    fi

    for PATTERN in "${PATTERNS[@]}"; do
        # Search for pattern in staged content (use -- to handle patterns starting with -)
        MATCHES=$(git diff --cached --diff-filter=ACM -p "$FILE" 2>/dev/null | grep -E "^\+" | grep -oE -- "$PATTERN" 2>/dev/null | head -3)

        if [ -n "$MATCHES" ]; then
            FOUND_SECRETS=1
            # Mask the secret for display (show first 8 and last 4 chars)
            for MATCH in $MATCHES; do
                if [ ${#MATCH} -gt 16 ]; then
                    MASKED="${MATCH:0:8}...${MATCH: -4}"
                else
                    MASKED="${MATCH:0:4}..."
                fi
                SECRETS_REPORT="${SECRETS_REPORT}\n  ${RED}[BLOCKED]${NC} ${FILE}: ${MASKED}"
            done
        fi
    done
done

if [ $FOUND_SECRETS -eq 1 ]; then
    echo -e "\n${RED}========================================${NC}"
    echo -e "${RED}  COMMIT BLOCKED - SECRETS DETECTED!${NC}"
    echo -e "${RED}========================================${NC}"
    echo -e "$SECRETS_REPORT"
    echo -e "\n${YELLOW}To fix this:${NC}"
    echo "  1. Remove the secrets from the files"
    echo "  2. Use environment variables or .env files instead"
    echo "  3. Make sure .env is in .gitignore"
    echo -e "\n${YELLOW}To bypass (NOT RECOMMENDED):${NC}"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi

echo -e "${GREEN}No secrets detected.${NC}"
exit 0
